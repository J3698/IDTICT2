package contest.winter2017;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 * This class represents a list of parameters with their values filled out. The
 * class is tailored such that the parameter strings may be used as part of a
 * tree in conjunction with UBC1 Monte-Carlo tree-search generation.
 * 
 * 
 * @author ICT-2
 */
class ParameterString implements Comparable<ParameterString> {
	/**
	 * The parameter factory to get new parameters.
	 */
	private ParameterFactory parameterFactory;

	/**
	 * The parent parameter string.
	 */
	private ParameterString parent;

	/**
	 * List of possible parameters given this parameter string.
	 */
	private List<Parameter> possibleParameters = null;

	/**
	 * List of filled out parameters for this parameter string.
	 */
	private List<String> parameters;

	/**
	 * List of parameters used by this parameter string.
	 */
	private HashSet<Parameter> usedParameters;

	/**
	 * List of children of this parameter string which may be expandable.
	 */
	private List<ParameterString> fertileChildren = null;

	/**
	 * List of all children generated by this parameter string.
	 */
	private List<ParameterString> allChildren = null;

	/**
	 * Number of unique lines found by this parameter string.
	 */
	private int uniqueLines;

	/**
	 * Number of times this parameter string or its children have been tested.
	 */
	private int childTests = 0;

	/**
	 * The average unique lines found by this parameter and its children.
	 */
	private double mean;

	/**
	 * Whether this parameter has been expanded.
	 */
	private boolean isExpanded;

	/**
	 * Whether this parameter is testable.
	 */
	private Boolean isTestable = null;

	/**
	 * Whether this parameter has been tested.
	 */
	private boolean isTested;

	/**
	 * Constructs a parameter string with the given parameter factory, used
	 * parameters, and parameters.
	 * 
	 * @param parameterFactory
	 *            - parameter factory to get parameters from
	 * @param usedParameters
	 *            - parameters to exclude when getting new parameters
	 * @param parameters
	 *            - parameters filled out already
	 */
	public ParameterString(ParameterFactory parameterFactory, HashSet<Parameter> usedParameters,
			List<String> parameters) {
		this.parameterFactory = parameterFactory;
		this.usedParameters = usedParameters;
		if (usedParameters == null) {
			this.usedParameters = new HashSet<Parameter>();
		}
		this.parameters = parameters;
		if (this.parameters == null) {
			this.parameters = new ArrayList<String>();
		}
	}

	/**
	 * Constructs a parameter string with the given parameter factory and
	 * parameters.
	 * 
	 * @param parameterFactory
	 *            - parameter factory to get parameters from
	 * @param parameters
	 *            - parameters filled out already
	 */
	public ParameterString(ParameterFactory parameterFactory, List<String> parameters) {
		this(parameterFactory, null, parameters);
	}

	/**
	 * Constructs a parameter string with the given parameter factory.
	 * 
	 * @param parameterFactory
	 *            - parameter factory to get parameters from
	 */
	public ParameterString(ParameterFactory parameterFactory) {
		this(parameterFactory, null, null);
	}

	/**
	 * Return whether this parameter has or can create children
	 * 
	 * @return true if this parameter has or can create children, otherwise
	 *         false
	 */
	public boolean isExpandable() {
		if (this.possibleParameters == null) {
			this.possibleParameters = this.parameterFactory.getNext(parameters, usedParameters);
		}

		boolean fertileDead = (this.fertileChildren != null && this.fertileChildren.isEmpty());
		return !possibleParameters.isEmpty() && !fertileDead;
	}

	/**
	 * Creates the children of this parameters.
	 */
	@SuppressWarnings("unchecked")
	public void expand() {
		if (this.fertileChildren == null) {
			this.possibleParameters = this.parameterFactory.getNext(parameters, usedParameters);
		}

		this.isExpanded = true;

		if (this.possibleParameters.size() == 0) {
			return;
		}

		this.fertileChildren = new ArrayList<ParameterString>();
		this.allChildren = new ArrayList<ParameterString>();

		Collections.sort(this.possibleParameters, new BranchFactorComparator());

		Parameter brancher = this.possibleParameters.get(0);
		HashSet<Parameter> newUsedParameters = (HashSet<Parameter>) this.usedParameters.clone();
		newUsedParameters.add(brancher);

		if (brancher.isEnumeration()) {
			addEnumerationChildren(brancher, newUsedParameters);
		} else {
			if (brancher.isFormatted()) {
				getFormattedChildren(brancher, newUsedParameters);
			} else {
				getRawChildren(brancher, newUsedParameters);
			}
			/*
			 * replace_all_but_first_replaceme_with_dummy_values(); if
			 * (first_replaceme_a_number()) { for option in
			 * getNumOptions(getMin, getMax); formatted =
			 * getformatted(dummyValedThing, List(option)); children.add(new
			 * ParameterString(formatted)); } else { for (option in
			 * dummyStringVals()) { formated = getFormated(dummyValedThing,
			 * List(option)); children.add(new ParamterString(formatted)); } }
			 */
		}
	}

	/**
	 * Expands the parameter string off of an enumerated parameter.
	 * 
	 * @param brancher
	 *            - parameter to create different branches from.
	 * @param newUsedParameters
	 *            - new set of used parameters for the children
	 */
	@SuppressWarnings("unchecked")
	public void addEnumerationChildren(Parameter brancher, HashSet<Parameter> newUsedParameters) {
		List<String> enumVals = brancher.getEnumerationValues();
		for (int i = 0; i < enumVals.size(); i++) {
			boolean numberFound = false;
			List<Object> formatVals = new LinkedList<Object>();
			String toFormat = enumVals.get(i);

			@SuppressWarnings("rawtypes")
			List<Class> formatTypes = Parameter.getFormatVariables(toFormat);
			for (Class<?> c : formatTypes) {
				if (Number.class.isAssignableFrom(c) && !numberFound) {
					numberFound = true;
					// could instead keep track of insertion point
					formatVals.add("<<LAST_NUMBER_TO_FORMAT>>");
				} else {
					if (Number.class.isAssignableFrom(c)) {
						formatVals.add(1);
					} else {
						formatVals.add("\"The lazy dog jumped over the quick brown fox.\"");
					}
				}
			}

			toFormat = Parameter.getFormattedParameter(toFormat, formatVals);

			if (toFormat.contains("<<LAST_NUMBER_TO_FORMAT>>")) {
				Number min = null;
				Number max = null;
				if (brancher.getMin() instanceof List) {
					min = ((List<Number>) brancher.getMin()).get(i);
				}
				if (brancher.getMax() instanceof List) {
					max = ((List<Number>) brancher.getMax()).get(i);
				}

				String dummyValue = "";
				if ((min == null || min.longValue() <= 1) && (max == null || max.longValue() <= 1)) {
					dummyValue = "1";
				} else if (min == null && max != null) {
					dummyValue = "" + (max.longValue() - 1);
				} else {
					dummyValue = "" + (min.longValue() + 1);
				}

				toFormat = toFormat.replace("<<LAST_NUMBER_TO_FORMAT>>", dummyValue);
			}

			List<String> copy = new ArrayList<String>(this.parameters);
			copy.add(toFormat);
			ParameterString newString = new ParameterString(this.parameterFactory, newUsedParameters, copy);
			newString.setParent(this);
			this.fertileChildren.add(newString);
			this.allChildren.add(newString);
		}
	}

	/**
	 * Expands the parameter string off of a formatted parameter.
	 * 
	 * @param brancher
	 *            - parameter to create different branches from.
	 * @param newUsedParameters
	 *            - new set of used parameters for the children
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void getFormattedChildren(Parameter brancher, HashSet<Parameter> newUsedParameters) {
		String toFormat = brancher.getFormat();
		List<Class> formatTypes = Parameter.getFormatVariables(toFormat);
		List<Object> formatVals = new ArrayList<Object>();
		boolean numberFound = false;

		if (formatTypes.get(0) != null) {
			formatVals.add("<<LAST_THING_TO_FORMAT>>");
			if (Number.class.isAssignableFrom(formatTypes.get(0))) {
				numberFound = true;
			}
		}

		for (int i = 1; i < formatTypes.size(); i++) {
			Class<?> c = formatTypes.get(i);

			if (Number.class.isAssignableFrom(c) && !numberFound) {
				numberFound = true;
				// format
				formatVals.add("<<LAST_NUMBER_TO_FORMAT>>");
			} else {
				if (Number.class.isAssignableFrom(c)) {
					formatVals.add(1);
				} else {
					formatVals.add("\"The lazy dog jumped over the quick brown fox.\"");
				}
			}
		}

		toFormat = Parameter.getFormattedParameter(toFormat, formatVals);

		if (toFormat.contains("<<LAST_NUMBER_TO_FORMAT>>")) {
			Number min = (Number) brancher.getMin();
			Number max = (Number) brancher.getMax();
			String dummyValue = "";
			if ((min == null || min.longValue() <= 1) && (max == null || max.longValue() <= 1)) {
				dummyValue = "1";
			} else if (min == null && max != null) {
				dummyValue = "" + (max.longValue() - 1);
			} else {
				dummyValue = "" + (min.longValue() + 1);
			}

			toFormat = toFormat.replace("<<LAST_NUMBER_TO_FORMAT>>", dummyValue);
		}

		if (!formatTypes.isEmpty()) {
			Set<Object> branches = new HashSet<Object>();
			if (Number.class.isAssignableFrom(formatTypes.get(0))) {
				branches.add(1);
				if (formatTypes.get(0).isAssignableFrom(Long.class)) {
					Long min = (Long) brancher.getMin();
					Long max = (Long) brancher.getMax();
					if (min != null) {
						branches.add(min);
						branches.add(min - 1);
					}
					if (max != null) {
						branches.add(max);
						branches.add(max + 1);
					}
				} else if (formatTypes.get(0).isAssignableFrom(Double.class)) {
					Double min = (Double) brancher.getMin();
					Double max = (Double) brancher.getMax();
					if (min != null) {
						branches.add(min);
						branches.add(min - 1);
					}
					if (max != null) {
						branches.add(max);
						branches.add(max + 1);
					}
				} else if (formatTypes.get(0).isAssignableFrom(Integer.class)) {
					Integer min = (Integer) brancher.getMin();
					Integer max = (Integer) brancher.getMax();
					if (min != null) {
						branches.add(min);
						branches.add(min - 1);
					}
					if (max != null) {
						branches.add(max);
						branches.add(max + 1);
					}
				}
			} else {
				branches.add("\"The l4zy dog jump3d 0ver the qu1ck brown fox.\"");
				branches.add("\"hi \n hi \t } \\n hi { hey\"");
				branches.add("\"brown fox\"");
			}

			for (Object branch : branches) {
				String formatted = toFormat.replaceAll("<<LAST_THING_TO_FORMAT>>", "" + branch);
				List<String> copy = new ArrayList<String>(this.parameters);
				copy.add(formatted);
				ParameterString newString = new ParameterString(this.parameterFactory, newUsedParameters, copy);
				newString.setParent(this);
				this.fertileChildren.add(newString);
				this.allChildren.add(newString);
			}
		}
	}

	/**
	 * Expands the parameter string off of a typed parameter.
	 * 
	 * @param brancher
	 *            - parameter to create different branches from.
	 * @param newUsedParameters
	 *            - new set of used parameters for the children
	 */
	@SuppressWarnings("unchecked")
	public void getRawChildren(Parameter brancher, HashSet<Parameter> newUsedParameters) {
		Set<Object> branches = new HashSet<Object>();
		if (Number.class.isAssignableFrom(brancher.getType())) {
			branches.add(1);
			if (brancher.getType().isAssignableFrom(Long.class)) {
				Long min = (Long) brancher.getMin();
				Long max = (Long) brancher.getMax();
				if (min != null) {
					branches.add(min);
					branches.add(min - 1);
				}
				if (max != null) {
					branches.add(max);
					branches.add(max + 1);
				}
			} else if (brancher.getType().isAssignableFrom(Double.class)) {
				Double min = (Double) brancher.getMin();
				Double max = (Double) brancher.getMax();
				if (min != null) {
					branches.add(min);
					branches.add(min - 1);
				}
				if (max != null) {
					branches.add(max);
					branches.add(max + 1);
				}
			} else if (brancher.getType().isAssignableFrom(Integer.class)) {
				Integer min = (Integer) brancher.getMin();
				Integer max = (Integer) brancher.getMax();
				if (min != null) {
					branches.add(min);
					branches.add(min - 1);
				}
				if (max != null) {
					branches.add(max);
					branches.add(max + 1);
				}
			}

		} else {
			branches.add("\"The l4zy dog jump3d 0ver the qu1ck brown fox.\"");
			branches.add("\"hi \n hi \t } \\n hi { hey\"");
			branches.add("\"brown fox\"");
		}

		for (Object branch : branches) {
			List<String> copy = new ArrayList<String>(this.parameters);
			copy.add("" + branch);
			ParameterString newString = new ParameterString(this.parameterFactory, newUsedParameters, copy);
			newString.setParent(this);
			this.fertileChildren.add(newString);
			this.allChildren.add(newString);
		}
	}

	/**
	 * Updates the mean unique lines found by this parameter string and its
	 * children.
	 */
	public void updateMean() {
		double total = this.uniqueLines;
		if (this.allChildren != null) {
			for (ParameterString child : this.allChildren) {
				total += child.childTests * child.mean;
			}
		}
		this.mean = total / this.childTests;

		if (this.parent != null) {
			this.parent.updateMean();
		}
	}

	/**
	 * Returns this parameter string's set of used parameters
	 * 
	 * @return the used parameters
	 */
	public Set<Parameter> getUsedParameters() {
		return this.usedParameters;
	}

	/**
	 * Adds found unique lines to this parameter string.
	 * 
	 * @param uniqueLines
	 *            - number of lines to add
	 */
	public void addUniqueness(int uniqueLines) {
		this.uniqueLines += uniqueLines;
	}

	/**
	 * Subtracts found unique lines to this parameter string.
	 * 
	 * @param uniqueLines
	 *            - number of lines to subtract
	 */
	public void subUniqueness(int uniqueLines) {
		this.uniqueLines -= uniqueLines;
	}

	/**
	 * Returns this parameter string's list of parameters as a string.
	 * 
	 * @return this parameter string's list of parameters as a string
	 */
	@Override
	public String toString() {
		String rep = "";
		for (String str : this.parameters) {
			rep += " " + str;
		}
		return rep;
	}

	/**
	 * Returns the children of this parameter string.
	 * 
	 * @return the children of this parameter string
	 */
	public List<ParameterString> getChildren() {
		if (this.fertileChildren == null) {
			expand();
		}
		return this.fertileChildren;
	}

	/**
	 * Returns the parent of this parameter string.
	 * 
	 * @return the parent of this parameter string
	 */
	public ParameterString getParent() {
		return this.parent;
	}

	/**
	 * Sets the parent of this parameter string.
	 * 
	 * @param parent
	 *            - the parent to set
	 */
	public void setParent(ParameterString parent) {
		this.parent = parent;
	}

	/**
	 * Returns whether this parameter has been tested.
	 * 
	 * @return true if this parameter has been tested, otherwise false
	 */
	public boolean isTested() {
		return this.isTested;
	}

	/**
	 * Returns whether this parameter is testable.
	 * 
	 * @return true if this parameter is testable, otherwise false
	 */
	public boolean isTestable() {
		if (this.isTestable != null) {
			return this.isTestable;
		}

		if (this.possibleParameters == null) {
			this.possibleParameters = this.parameterFactory.getNext(parameters, usedParameters);
		}

		for (Parameter param : this.possibleParameters) {
			if (!param.isOptional()) {
				this.isTestable = false;
				return false;
			}
		}

		this.isTestable = true;
		return this.isTestable;
	}

	/**
	 * Sets the tested state of this parameter string to true.
	 */
	public void setTested() {
		if (!this.isTested) {
			this.isTested = true;
			setChildTested();
		}
	}

	/**
	 * Increments number of child tests counted.
	 */
	public void setChildTested() {
		this.childTests++;
		if (this.parent != null) {
			this.parent.setChildTested();
		}
	}

	/**
	 * 
	 * @return
	 */
	public boolean isExpanded() {
		return this.isExpanded;
	}

	/**
	 * Returns the most profitable child from this parameter string's children.
	 * 
	 * @return the most profitable child from this parameter string's children
	 */
	public ParameterString bestChild() {
		Collections.sort(this.fertileChildren);
		return this.fertileChildren.get(0);
	}

	/**
	 * Removes this parameter string from its parent's fertile children.
	 */
	public void removeFromParent() {
		if (this.parent != null) {
			this.parent.removeChild(this);
		}
	}

	/**
	 * Removes a fertile child from this parameter strings children.
	 * 
	 * @param parameterString
	 *            - parameter string which is no longer fertile.
	 */
	private void removeChild(ParameterString parameterString) {
		this.fertileChildren.remove(parameterString);
	}

	/**
	 * Returns the upper confidence bound for this parameter-string's score.
	 * 
	 * @return the upper confidence bound for this parameter-string's score
	 */
	public double upperBound() {
		double frac = 2 * Math.log(parent.childTests) / this.childTests;
		return this.mean + Math.sqrt(frac);
	}

	/**
	 * Compares this parameter string to another parameter string.
	 * <p>
	 * The parameter string with the higher upper bound goes first in a list.
	 * 
	 * @return an int whose sign represents the ordering of the two parameter
	 *         strings
	 */
	public int compareTo(ParameterString other) {
		double num = other.upperBound() - this.upperBound();
		return num == 0 ? 0 : num > 0 ? 1 : -1;
	}
}

/**
 * 
 * @author ICT-2
 *
 */
class BranchFactorComparator implements Comparator<Parameter> {
	/**
	 * Branching factor for a string.
	 */
	private static final int stringBranchFactor = 4;

	/**
	 * Compares two parameters.
	 * <p>
	 * The parameter with the higher branching factor goes first in the list.
	 */
	@Override
	public int compare(Parameter first, Parameter second) {
		// TODO Auto-generated method stub
		return branchFactor(second) - branchFactor(first);
	}

	/**
	 * Returns the branching factor of a parameter.
	 * 
	 * @param parameter
	 *            - parameter to find the branching factor for
	 * @return the branching factor for the given parameter
	 */
	public int branchFactor(Parameter parameter) {
		if (parameter.isEnumeration()) {
			return parameter.getEnumerationValues().size();
		} else if (parameter.getType() == String.class) {
			return stringBranchFactor;
		} else {
			Number min = (Number) parameter.getMin();
			Number max = (Number) parameter.getMax();
			if (max != null && min != null && min.equals(max)) {
				return 3;
			}
			return 5;
		}
	}
}