	private Output instrumentAndExecuteCode(Object[] parameters) {
		Process process = null;
		Output output = new Output();

		// we are building up a command line statement that will use java -jar
		// to execute the jar
		// and uses jacoco to instrument that jar and collect code coverage
		// metrics
		String command = "java";
		try {
			// http://stackoverflow.com/questions/6780678/run-class-in-jar-file

			if (runningFromJar()) {
				System.out.println("Running from Jar.");
				command += " -javaagent:" + this.jacocoAgentJarPath + "=destfile=" + this.jacocoOutputFilePath;
				command += " -cp" + " com.idtus.contest.winter2017.framework.jar ";
				command += SecurityWatchdog.class.getCanonicalName();
				command += " \"" + this.jarToTestPath + "\" " + this.toolChain;
			} else {
				command += " -javaagent:" + this.jacocoAgentJarPath + "=destfile=" + this.jacocoOutputFilePath;
				command += " -cp \"" + this.watchdogPath + "\" ";
				command += SecurityWatchdog.class.getCanonicalName();
				command += " \"" + this.jarToTestPath + "\" " + this.toolChain;
			}

			for (Object o : parameters) {
				command += " " + o.toString();
			}

			// show the user the command to run and prepare the process using
			// the command

			if (!this.toolChain) {
				System.out.println("command to run: " + command);
			}

			process = Runtime.getRuntime().exec(command);

			// prepare the stream needed to capture standard output
			InputStream isOut = process.getInputStream();
			InputStreamReader isrOut = new InputStreamReader(isOut);
			BufferedReader brOut = new BufferedReader(isrOut);
			StringBuffer stdOutBuff = new StringBuffer();

			// prepare the stream needed to capture standard error
			InputStream isErr = process.getErrorStream();
			InputStreamReader isrErr = new InputStreamReader(isErr);
			BufferedReader brErr = new BufferedReader(isrErr);
			StringBuffer stdErrBuff = new StringBuffer();

			String line;
			boolean outDone = false;
			boolean errDone = false;

			// while standard out is not complete OR standard error is not
			// complete
			// continue to probe the output/error streams for the applications
			// output
			int i = 0;
			while ((!outDone || !errDone)) {
				// monitoring the standard output from the application
				boolean outReady = brOut.ready();
				if (outReady) {
					line = brOut.readLine();
					if (line == null) {
						outDone = true;
					} else if (line.equals("<<WATCHDOG_OUTPUT_START>>")) {
						handleWatchdogOutput(brOut, output);
					} else {
						stdOutBuff.append(line);
					}
				}

				// monitoring the standard error from the application
				boolean errReady = brErr.ready();
				if (errReady) {
					line = brErr.readLine();
					if (line == null) {
						errDone = true;
					} else {
						if (line.equals("<<WATCHDOG_OUTPUT_START>>")) {
							handleWatchdogError(brErr);
						} else {
							stdErrBuff.append(line + "\n");
						}
					}
				}

				// if standard out and standard error are not ready, wait for
				// 250ms
				// and try again to monitor the streams
				if (!outReady && !errReady) {
					i++;
					if (i > 6) {
						break;
					}
					try {
						Thread.sleep(250);
					} catch (InterruptedException e) {
						// NOP
					}
				}
			}

			while (brErr.ready()) {
				stdErrBuff.append(brErr.readLine());
			}

			// we now have the output as an object from the run of the black-box
			// jar
			// this output object contains both the standard output and the
			// standard error

			output.setStdOutString(stdOutBuff.toString());
			// trim extra newline character
			if (stdErrBuff.length() != 0) {
				stdErrBuff.deleteCharAt(stdErrBuff.length() - 1);
			}
			output.setStdErrString(stdErrBuff.toString());

		} catch (IOException e) {
			if (!this.toolChain) {
				System.out.println("ERROR: IOException has prevented execution of the command: " + command);
			}
			e.printStackTrace();
			return null;
		} catch (WatchdogException e) {
			if (!this.toolChain) {
				System.out.println("ERROR: WatchdogException has prevented execution of the command: " + command);
			}
			e.printStackTrace();
			return null;
		}

		this.outputs.add(output);
		this.exceptionSet.addAll(output.getExceptions());

		double totalTests = this.bbTests + this.predefinedTests.size();
		percentDone.set(outputs.size() / totalTests);

		return output;
	}